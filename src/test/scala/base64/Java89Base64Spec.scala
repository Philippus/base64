package base64

import java.util.Base64

import org.scalatest.FunSpec

// all expected output generated by apache commons codec
class Java89Base64Spec extends FunSpec {
  describe ("Encode Java89") {
    it ("should allow url unsafe output") {
      assert(new String(Base64.getEncoder.encode("hello world?".getBytes)) === "aGVsbG8gd29ybGQ/")
    }

    it ("should encode short strings") {
      (("f", "Zg==") :: ("fo", "Zm8=") :: ("foo", "Zm9v") :: Nil).foreach {
        case (in, out) => assert(new String(Base64.getEncoder.encode(in.getBytes)) === out)
      }
    }

    it ("should encode with and without padding") {
      val str = "easure."
      def check(pad: Boolean, expect: Array[Byte]) {
        val enc = {
          if (pad)
            Base64.getEncoder.encode(str.getBytes)
          else
            Base64.getEncoder.withoutPadding.encode(str.getBytes)
        }
        assert(enc === expect)
        assert(new String(Base64.getDecoder.decode(enc)) === str)
      }
      check(true, "ZWFzdXJlLg==".getBytes)
      check(false, "ZWFzdXJlLg".getBytes)
    }

    it ("should support multiline encoding") {
      val expect = "QmFzZTY0IGlzIGEgZ3JvdXAgb2Ygc2ltaWxhciBiaW5hcnktdG8tdGV4dCBlbmNvZGluZyBzY2hl\r\nbWVzIHRoYXQgcmVwcmVzZW50IGJpbmFyeSBkYXRhIGluIGFuIEFTQ0lJIHN0cmluZyBmb3JtYXQg\r\nYnkgdHJhbnNsYXRpbmcgaXQgaW50byBhIHJhZGl4LTY0IHJlcHJlc2VudGF0aW9uLiBUaGUgdGVy\r\nbSBCYXNlNjQgb3JpZ2luYXRlcyBmcm9tIGEgc3BlY2lmaWMgTUlNRSBjb250ZW50IHRyYW5zZmVy\r\nIGVuY29kaW5nLg=="
      val in = "Base64 is a group of similar binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. The term Base64 originates from a specific MIME content transfer encoding."
      assert(new String(java.util.Base64.getMimeEncoder().encode(in.getBytes)) == expect)
    }
  }

  describe ("EncodeJava89.urlSafe") {
    it ("should escape url unsafe output") {
      assert(new String(Base64.getUrlEncoder.encode("hello world?".getBytes)) === "aGVsbG8gd29ybGQ_")
    }

  }

  describe ("DecodeJava89") {
    it ("should not bother decoding pad only input") {
      intercept[IllegalArgumentException] {
      ("====" :: "===" :: "==" :: "=" :: Nil).foreach {
          p => new String(Base64.getDecoder.decode(p))
        }
      }
    }

    it ("should decode url unsafe strs") {
      assert(new String(Base64.getDecoder.decode("aGVsbG8gd29ybGQ/")) === "hello world?")
    }

  }

  describe ("DecodeJava89.urlSafe") {
    it ("should decode urlsafe strs") {
      assert(new String(Base64.getUrlDecoder.decode("aGVsbG8gd29ybGQ_")) === "hello world?")
    }
  }

  def str(bytes: Array[Byte]) = new String(bytes)
}
